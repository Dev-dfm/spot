// ignore_for_file: require_trailing_commas

import 'package:dartx/dartx.dart';
import 'package:flutter/widgets.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:spot/spot.dart';
import 'package:spot/src/checks/context.dart';

/// Matchers for [Text] auto-generated by spot
///
/// ```dart
/// spot<Text>().printMatchers(propNameOverrides: (MapEntry('data': 'text')));
/// ```
extension EffectiveTextMatcher on WidgetMatcher<Text> {
  WidgetMatcher<Text> hasEffectiveMaxLinesWhere(MatchProp<int?> match) {
    return _hasEffectiveMaxLinesWhere(match);
  }

  WidgetMatcher<Text> hasEffectiveMaxLines(int? value) {
    return _hasEffectiveMaxLinesWhere((it) => it.equals(value));
  }

  WidgetMatcher<Text> _hasEffectiveMaxLinesWhere(MatchProp<int?> match) {
    final richTextElement =
        element.children.firstWhere((e) => e.widget is RichText);
    final richText = richTextElement.widget as RichText;
    final actual = richText.maxLines;
    final ConditionSubject<int?> conditionSubject = it<int?>();
    final Subject<int?> subject = conditionSubject.context.nest<int?>(
      () => ['with prop "maxLines"'],
      (value) => Extracted.value(actual),
    );
    match(subject);
    final failure = softCheck(actual, conditionSubject);
    if (failure != null) {
      final errorMessage =
          describe(conditionSubject).map((it) => it.trim()).toList().join(' ');
      throw TestFailure(
        'Failed to match widget: $errorMessage, actual: ${literal(actual).joinToString()}',
      );
    }
    return this;
  }
}

extension EffectiveTextSelector on WidgetSelector<Text> {
  WidgetSelector<Text> withEffectiveMaxLinesMatching(MatchProp<int?> match) {
    return _withEffectiveMaxLinesMatching(match);
  }

  WidgetSelector<Text> withEffectiveMaxLines(int? value) {
    return _withEffectiveMaxLinesMatching((it) => it.equals(value));
  }

  WidgetSelector<Text> _withEffectiveMaxLinesMatching(MatchProp<int?> match) {
    final ConditionSubject<Element> conditionSubject = it<Element>();
    final Subject<int?> subject = conditionSubject.context.nest<int?>(
      () => ['with prop "maxLines"'],
      (Element element) {
        final richTextElement =
            element.children.firstWhere((e) => e.widget is RichText);
        final richText = richTextElement.widget as RichText;
        return Extracted.value(richText.maxLines);
      },
    );
    match(subject);
    final name =
        describe(conditionSubject).map((it) => it.trim()).toList().join(' ');

    return whereElement(
      (element) {
        final failure = softCheck(element, conditionSubject);
        return failure == null;
      },
      description: name,
    );
  }
}
